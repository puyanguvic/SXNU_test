### 题干

**五、简答题（每小题 9 分，共 18 分）**

### 1. 假设某密文仅由 8 个字母 S, T, U, V, W, X, Y, Z 组成，各字母在密文中出现的频率分别为 6, 26, 31, 7, 10, 3, 12, 5。
   - (1) 画出对应的 Huffman 树（按左子树根节点的权小于等于右子树根节点的权的次序构造）。(6 分)
   - (2) 计算相应 Huffman 树的加权路径长度。(3 分)

(1) **Huffman 树构造**：

根据字母的频率，我们首先将每个字母和对应的频率作为一个节点插入最小堆中，然后执行以下步骤：

1. 每次从堆中取出两个最小频率的节点，合并为一个新节点，新节点的频率为两者之和。
2. 将新节点插回堆中。
3. 重复步骤 1 和 2，直到堆中只剩一个节点，即为 Huffman 树的根节点。

根据频率构造 Huffman 树的过程如下：

- 初始频率：{3, 5, 6, 7, 10, 12, 26, 31}
- 合并过程示例：
  1. 合并 `3` 和 `5` 得到新节点 `8`。
  2. 合并 `6` 和 `7` 得到新节点 `13`。
  3. 按此方法依次合并，构建 Huffman 树。

(2) **Huffman 树的加权路径长度计算**：

计算公式为：
\[
WPL = \sum_{i=1}^{n} (频率 \times 深度)
\]

依次计算每个字母到根节点的路径长度乘以其频率，求和得到 Huffman 树的加权路径长度。

---

### 2. 设待排序的关键字序列为 {50, 39, 66, 98, 77, 14, 28, 49, 56, 3, 5}，试写出使用希尔排序（增量选择 {5, 3, 1}，每趟排序结束后关键字序列的状态，按非递减序排列）。(9 分)

关键字序列为 {50, 39, 66, 98, 77, 14, 28, 49, 56, 3, 5}，增量序列为 {5, 3, 1}。

1. **增量为 5 时的排序**：
   - 对间隔为 5 的元素进行排序。

2. **增量为 3 时的排序**：
   - 对间隔为 3 的元素进行排序。

3. **增量为 1 时的排序**（即直接插入排序）：
   - 完成最终排序。

逐步完成每轮排序后，记录排序状态。

---


**六、算法设计（15 分）**

两个字符串序列 \( M = m_1, m_2, \dots, m_i \) 和 \( N = n_1, n_2, \dots, n_j \) 已经存入两个单链表中。本题假定单链表中均无头结点，单链表中的节点包含两个域：
- `data` 域：保存字符。
- `next` 指针：指向当前节点的后继。

设计一个算法判断序列 \( N \) 是否是序列 \( M \) 的子序列。

---

**判断链表 \( N \) 是否是链表 \( M \) 的子序列**

**解题思路**：

1. 使用双指针 `pM` 和 `pN` 分别指向链表 \( M \) 和链表 \( N \) 的当前节点。
2. 如果 `pM->data == pN->data`，则同时移动 `pM` 和 `pN`。
3. 如果 `pM->data != pN->data`，则仅移动 `pM`, pN重置为N的第一个节点。
4. 当 `pN` 到达链表末尾（即 `pN == NULL`）时，说明 \( N \) 是 \( M \) 的子序列；如果 `pM` 到达链表末尾而 `pN` 还没有匹配完，说明 \( N \) 不是 \( M \) 的子序列。

**代码实现**：

```c
#include <stdio.h>
#include <stdbool.h>

typedef struct Node {
    char data;
    struct Node *next;
} Node;

bool isSubsequence(Node *M, Node *N) {
    Node *pM = M;
    Node *pN = N;

    while (pM && pN) {
        if (pM->data == pN->data) {
            pN = pN->next;  // 匹配成功，移动 N 的指针
        }
        pM = pM->next;  // 无论是否匹配成功，M 的指针都要移动
    }

    return pN == NULL;  // 如果 N 匹配完了，说明 N 是 M 的子序列
}
```

**代码说明**：

1. 初始化指针 `pM` 指向链表 \( M \) 的头节点，`pN` 指向链表 \( N \) 的头节点。
2. 遍历链表 \( M \) 的每个节点，与链表 \( N \) 的当前节点进行匹配。
3. 如果链表 \( N \) 完全匹配，则返回 `true`；否则返回 `false`。
